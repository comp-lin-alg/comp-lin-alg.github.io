<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5. Finding eigenvalues of matrices &#8212; Computational linear algebra course 2023.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/fenics.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/proof.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. Iterative Krylov methods for \(Ax=b\)" href="L6_krylov.html" />
    <link rel="prev" title="4. Analysing algorithms" href="L3_analysing_algorithms.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">


<link rel="shortcut icon" href="_static/icon.ico" />


  </head><body>
<div class="wrapper">
  <a href="index.html"><img src="_static/banner.png" width="900px" alt="Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="https://github.com/Computational-Linear-Algebra-Course/computational-linear-algebra-course" title="GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="finding-eigenvalues-of-matrices">
<h1><span class="section-number">5. </span>Finding eigenvalues of matrices<a class="headerlink" href="#finding-eigenvalues-of-matrices" title="Permalink to this heading">¶</a></h1>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454117340" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>We start with some preliminary terminology.  A vector <span class="math notranslate nohighlight">\(x\in
\mathbb{C}^m\)</span> is an <em>eigenvector</em> of a square matrix <span class="math notranslate nohighlight">\(A\in
\mathbb{C}^{m\times m}\)</span> with <em>eigenvalue</em> <span class="math notranslate nohighlight">\(\lambda\)</span> if <span class="math notranslate nohighlight">\(Ax=\lambda
x\)</span>. An eigenspace is the subspace <span class="math notranslate nohighlight">\(E_{\lambda}\subset\mathbb{C}^m\)</span>
containing all eigenvectors of <span class="math notranslate nohighlight">\(A\)</span> with eigenvalue <span class="math notranslate nohighlight">\(\lambda\)</span>.</p>
<p>There are a few reasons why we are interested in computing
eigenvectors and eigenvalues of a matrix <span class="math notranslate nohighlight">\(A\)</span>.</p>
<ol class="arabic simple">
<li><p>Eigenvalues and eigenvectors encode information about <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p>Eigenvalues play an important role in stability calculations
in physics and engineering.</p></li>
<li><p>We can use eigenvectors to underpin the solution of linear systems
involving <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p>…</p></li>
</ol>
<section id="how-to-find-eigenvalues">
<h2><span class="section-number">5.1. </span>How to find eigenvalues?<a class="headerlink" href="#how-to-find-eigenvalues" title="Permalink to this heading">¶</a></h2>
<p>The method that we first encounter in our mathematical education is to
find solutions of <span class="math notranslate nohighlight">\((A-\lambda I)x = 0\)</span>, which implies that
<span class="math notranslate nohighlight">\(\det(A-\lambda I)=0\)</span>. This gives a degree <span class="math notranslate nohighlight">\(m\)</span> polynomial to solve for
<span class="math notranslate nohighlight">\(\lambda\)</span>, called the <em>characteristic polynomial</em>. Unfortunately,
there is no general solution for polynomials of degree 5 or greater
(from Galois theory). Further, the problem of finding roots of
polynomials is numerically unstable. All of this means that we should
avoid using polynomials finding eigenvalues. Instead, we should try to
apply transformations to the matrix <span class="math notranslate nohighlight">\(A\)</span> to a form that means that the
eigenvalues can be directly extracted.</p>
<div class="proof proof-type-example" id="id2">

    <div class="proof-title">
        <span class="proof-type">Example 5.1</span>
        
    </div><div class="proof-content">
<p>Consider the <span class="math notranslate nohighlight">\(m\times m\)</span> diagonal matrix</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}A = \begin{pmatrix}
1 &amp; 0 &amp; \ldots &amp; \ldots &amp; 0 \\
0 &amp; 2 &amp; \ldots &amp; \ldots &amp;0 \\
0 &amp; 0 &amp; \ddots &amp; \ddots &amp; \vdots \\
\vdots &amp; \vdots &amp; \ldots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \ldots &amp; \ldots &amp; m \\
\end{pmatrix}.\end{split}\]</div>
</div></blockquote>
<p>The characteristic polynomial of <span class="math notranslate nohighlight">\(A\)</span> is</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[(\lambda-1)(\lambda-2)\ldots(\lambda-m),\]</div>
</div></blockquote>
<p>and the eigenvalues are clearly <span class="math notranslate nohighlight">\(1,2,3,\ldots,m\)</span>. This is called
the Wilkinson Polynomial. Numpy has some tools for manipulating
polynomials which are useful here. When an <span class="math notranslate nohighlight">\(m\times m\)</span> array is
passed in to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.poly.html#numpy.poly" title="(in NumPy v2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.poly()</span></code></a>, it returns an array of
coefficients of the polynomial. For <span class="math notranslate nohighlight">\(m=20\)</span>, obtain this array and
then perturb the coefficients <span class="math notranslate nohighlight">\(a_k \to \tilde{a}_k =
a_k(1+10^{-10}r_k)\)</span> where <span class="math notranslate nohighlight">\(r_k\)</span> are randomly sampled normally
distributed numbers with mean 0 and variance 1. <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots" title="(in NumPy v2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.roots()</span></code></a>
will compute the roots of this perturbed polynomial. Plot these
roots as points in the complex plane. Repeat this 100 times,
superposing the root plots on the same graph. What do you observe?
What does it tell you about this problem and what should we
conclude about the wisdom of finding eigenvalues using
characteristic polynomials?</p>
</div></div><details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454118485" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>The eigenvalue decomposition of a matrix <span class="math notranslate nohighlight">\(A\)</span> finds a nonsingular matrix
<span class="math notranslate nohighlight">\(X\)</span> and a diagonal matrix <span class="math notranslate nohighlight">\(\Lambda\)</span> such that</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A = X\Lambda X^{-1}.\]</div>
</div></blockquote>
<p>The diagonal entries of <span class="math notranslate nohighlight">\(\Lambda\)</span> are the eigenvalues of <span class="math notranslate nohighlight">\(A\)</span>. Hence,
if we could find the eigenvalue decomposition of <span class="math notranslate nohighlight">\(A\)</span>, we could just
read off the eigenvalues of <span class="math notranslate nohighlight">\(A\)</span>; the eigenvalue decomposition is
“eigenvalue revealing”. Unfortunately, it is not always easy or even
possible to transform to an eigenvalue decomposition. Hence we shall
look into some other eigenvalue revealing decompositions of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>We quote the following result that explains when an eigenvalue
decomposition can be found.</p>
<div class="proof proof-type-theorem" id="id3">

    <div class="proof-title">
        <span class="proof-type">Theorem 5.2</span>
        
    </div><div class="proof-content">
<p>An <span class="math notranslate nohighlight">\(m\times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span> has an eigenvalue decomposition if and
only if it is non-defective, meaning that the geometric
multiplicity of each eigenvalue (the dimension of the eigenspace
for that eigenvalue) is equal to the algebraic multiplicity (the
number of times that the eigenvalue is repeated as a root in the
characteristic polynomial <span class="math notranslate nohighlight">\(\det(I\lambda - A)=0\)</span>.</p>
</div></div><p>If the algebraic multiplicity is greater than the geometric
multiplicity for any eigenvalue of <span class="math notranslate nohighlight">\(A\)</span>, then the matrix is defective,
the eigenspaces do not span <span class="math notranslate nohighlight">\(\mathbb{C}^m\)</span>, and an eigenvalue
decomposition is not possible.</p>
<p>This all motivates the search for other eigenvalue revealing
decompositions of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454122744" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><div class="proof proof-type-definition" id="id4">

    <div class="proof-title">
        <span class="proof-type">Definition 5.3</span>
        
            <span class="proof-title-name">(Similarity transformations)</span>
        
    </div><div class="proof-content">
<p>For <span class="math notranslate nohighlight">\(X\in \mathbb{C}^{m\times m}\)</span> a nonsingular matrix, the map
<span class="math notranslate nohighlight">\(A\mapsto X^{-1}AX\)</span> is called a similarity transformation of <span class="math notranslate nohighlight">\(A\)</span>.
Two matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are <em>similar</em> if <span class="math notranslate nohighlight">\(B=X^{-1}AX\)</span>.</p>
</div></div><p>The eigenvalue decomposition shows that (when it exists), <span class="math notranslate nohighlight">\(A\)</span> is similar
to <span class="math notranslate nohighlight">\(\Lambda\)</span>. The following result shows that it may be useful to examine
other similarity transformations.</p>
<div class="proof proof-type-theorem" id="id5">

    <div class="proof-title">
        <span class="proof-type">Theorem 5.4</span>
        
    </div><div class="proof-content">
<p>Two similar matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> have the same characteristic polynomial,
eigenvalues, and geometric multiplicities.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>See a linear algebra textbook.</p>
</div></div><p>The goal is to find a similarity transformation such that <span class="math notranslate nohighlight">\(A\)</span> is
transformed to a matrix <span class="math notranslate nohighlight">\(B\)</span> that has some simpler structure where the
eigenvalues can be easily computed (with the diagonal matrix of the
eigenvalue decomposition being one example).</p>
<p>One such transformation comes from the Schur factorisation.</p>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454122918" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><div class="proof proof-type-definition" id="id6">

    <div class="proof-title">
        <span class="proof-type">Definition 5.5</span>
        
            <span class="proof-title-name">(Schur factorisation)</span>
        
    </div><div class="proof-content">
<p>A Schur factorisation of a square matrix <span class="math notranslate nohighlight">\(A\)</span> takes the form <span class="math notranslate nohighlight">\(A =
QTQ^*\)</span>, where <span class="math notranslate nohighlight">\(Q\)</span> is unitary (and hence <span class="math notranslate nohighlight">\(Q^*=Q^{-1}\)</span>) and <span class="math notranslate nohighlight">\(T\)</span> is
upper triangular.</p>
</div></div><p>It turns out that, unlike the situation for the eigenvalue
decomposition, the following is true.</p>
<div class="proof proof-type-theorem" id="id7">

    <div class="proof-title">
        <span class="proof-type">Theorem 5.6</span>
        
    </div><div class="proof-content">
<p>Every square matrix has a Schur factorisation.</p>
</div></div><p>This is useful, because the characteristic polynomial of an upper
triangular matrix is just <span class="math notranslate nohighlight">\(\prod_{i=1}^m (\lambda-T_{ii})\)</span>, i.e.  the
eigenvalues of <span class="math notranslate nohighlight">\(T\)</span> are the diagonal entries
<span class="math notranslate nohighlight">\((T_{11},T_{22},\ldots,T_{mm})\)</span>. So, if we can compute the Schur
factorisation of <span class="math notranslate nohighlight">\(A\)</span>, we can just read the eigenvalues from the diagonal
matrices of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>There is a special case of the Schur factorisation, called the unitary
diagonalisation</p>
<div class="proof proof-type-definition" id="id8">

    <div class="proof-title">
        <span class="proof-type">Definition 5.7</span>
        
            <span class="proof-title-name">(Unitary diagonalisation)</span>
        
    </div><div class="proof-content">
<p>A unitary diagonalisation of a square matrix <span class="math notranslate nohighlight">\(A\)</span> takes the form <span class="math notranslate nohighlight">\(A =
Q\Lambda Q^*\)</span>, where <span class="math notranslate nohighlight">\(Q\)</span> is unitary (and hence <span class="math notranslate nohighlight">\(Q^*=Q^{-1}\)</span>) and <span class="math notranslate nohighlight">\(\Lambda\)</span>
is diagonal.</p>
</div></div><p>A unitary diagonalisation is a Schur factorisation <em>and</em> an eigenvalue
decomposition.</p>
<div class="proof proof-type-theorem" id="id9">

    <div class="proof-title">
        <span class="proof-type">Theorem 5.8</span>
        
    </div><div class="proof-content">
<p>A Hermitian matrix is unitary diagonalisable, with real <span class="math notranslate nohighlight">\(\Lambda\)</span>.</p>
</div></div><p>Hence, if we have a Hermitian matrix, we can follow a Schur
factorisation strategy (such as we shall develop in this section), and
obtain an eigenvalue decomposition as a bonus.</p>
</section>
<section id="transformations-to-schur-factorisation">
<h2><span class="section-number">5.2. </span>Transformations to Schur factorisation<a class="headerlink" href="#transformations-to-schur-factorisation" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454123177" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>Just as for the QR factorisations, we will compute the Schur
factorisation successively, with multiplication by a sequence of
unitary matrices <span class="math notranslate nohighlight">\(Q_1,Q_2,\ldots\)</span>. There are two differences for the
Schur factorisation. First, the matrices must be multiplied not just
on the left but also on the right with the inverse, i.e.</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A \mapsto \underbrace{Q_1^*AQ_1}_{A_1} \mapsto \underbrace{Q_2^*Q_1^*AQ_1Q_2}_{A_2}, \ldots\]</div>
</div></blockquote>
<p>At each stage, we have a similarity transformation,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A = \underbrace{Q_1Q_2\ldots Q_k}_{=Q}A_k\underbrace{Q_k^*\ldots Q_2^*Q_1^*}_{=Q^*},\]</div>
</div></blockquote>
<p>i.e. <span class="math notranslate nohighlight">\(A\)</span> is similar to <span class="math notranslate nohighlight">\(A_k\)</span>. Second, the successive sequence is
infinite, i.e. we will develop an iterative method that converges in
the limit <span class="math notranslate nohighlight">\(k\to\infty\)</span>.  We should terminate the iterative method
when <span class="math notranslate nohighlight">\(A_k\)</span> is sufficiently close to being upper triangular (which
can be measured by checking some norm on the lower triangular part
of <span class="math notranslate nohighlight">\(A\)</span> and stopping when it is below a tolerance).</p>
<p>We should not be surprised by the news that the method needs to be
iterative, since if the successive sequence were finite, we would have
derived an explicit formula for computing the eigenvalues of the
characteristic polynomial of <span class="math notranslate nohighlight">\(A\)</span> which is explicit in general.</p>
<p>In fact, there are two stages to this process. The first stage, which
is finite (takes <span class="math notranslate nohighlight">\(m-1\)</span> steps) is to use similarity transformations to
upper Hessenberg form (<span class="math notranslate nohighlight">\(H_{ij}=0\)</span> for <span class="math notranslate nohighlight">\(i&gt;j+1\)</span>). If <span class="math notranslate nohighlight">\(A\)</span> is Hermitian,
then <span class="math notranslate nohighlight">\(H\)</span> will be tridiagonal. This stage is not essential but it makes
the second, iterative, stage much faster.</p>
</section>
<section id="similarity-transformation-to-upper-hessenberg-form">
<h2><span class="section-number">5.3. </span>Similarity transformation to upper Hessenberg form<a class="headerlink" href="#similarity-transformation-to-upper-hessenberg-form" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454123306" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>We already know how to use a unitary matrix to set all entries to zero
below the diagonal in the first column of <span class="math notranslate nohighlight">\(A\)</span> by left multiplication
<span class="math notranslate nohighlight">\(Q^*_1A\)</span>, because this is the Householder algorithm. The problem is
that we then have to right multiply by <span class="math notranslate nohighlight">\(Q_1\)</span> to make it a similarity
transformation, and this puts non-zero entries back in the column
again. The easiest way to see this is to write
<span class="math notranslate nohighlight">\(Q_1^*AQ_1=(Q_1^*(Q_1^*A)^*)^*\)</span>. <span class="math notranslate nohighlight">\((Q_1^*A)^*\)</span> has zeros in the first
row to the right of the first entry. Then, <span class="math notranslate nohighlight">\(Q_1^*(Q_1^*A)\)</span> creates
linear combinations of the first column with the other columns,
filling the zeros in with non-zero values again. Then finally taking
the adjoint doesn’t help with these non-zero values. Again, we
shouldn’t be surprised that this is impossible, because if it was,
then we would be able to build a finite procedure for computing
eigenvalues of the characteristic polynomial, which is impossible in
general.</p>
<div class="proof proof-type-exercise" id="id10">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.9</span>
        
    </div><div class="proof-content">
<p>The <a class="reference internal" href="cla_utils.html#cla_utils.exercises8.Q1AQ1s" title="cla_utils.exercises8.Q1AQ1s"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises8.Q1AQ1s()</span></code></a> function has been left
uncompleted. It should apply the Householder transformation <span class="math notranslate nohighlight">\(Q_1\)</span>
to the input <span class="math notranslate nohighlight">\(A\)</span> (without forming <span class="math notranslate nohighlight">\(Q_1\)</span> of course) that transforms
the first column of <span class="math notranslate nohighlight">\(A\)</span> to have zeros below the diagonal, and then
apply a transformation equivalent to right multiplication by
<span class="math notranslate nohighlight">\(Q_1^*\)</span> (again without forming <span class="math notranslate nohighlight">\(Q_1\)</span>).  The test script
<code class="docutils literal notranslate"><span class="pre">test_exercises8.py</span></code> in the <code class="docutils literal notranslate"><span class="pre">test</span></code> directory will test this
function.</p>
<p>Experiment with the output of this function. What happens to the
first column?</p>
</div></div><p>A slight modification of this idea (and the reason that we can
transform to upper Hessenberg form) is to use a Householder rotation
<span class="math notranslate nohighlight">\(Q_1^*\)</span> to set all entries to zero below the <em>second</em> entry in the
first column. This matrix leaves the first row unchanged, and hence
right multiplication by <span class="math notranslate nohighlight">\(Q_1\)</span> leaves the first column unchanged. We
can create zeros using <span class="math notranslate nohighlight">\(Q_1^*\)</span> and <span class="math notranslate nohighlight">\(Q_1\)</span> will not destroy them. This
procedure is then repeated with multiplication by <span class="math notranslate nohighlight">\(Q_2^*\)</span>, which
leaves the first two rows unchanged and puts zeros below the third
entry in the second column, which are not spoiled by right
multiplication by <span class="math notranslate nohighlight">\(Q_2\)</span>. Hence, we can transform <span class="math notranslate nohighlight">\(A\)</span> to a similar
upper Hessenberg matrix <span class="math notranslate nohighlight">\(H\)</span> in <span class="math notranslate nohighlight">\(m-2\)</span> iterations.</p>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454123643" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>This reduction to Hessenberg form can be expressed in the following
pseudo-code.</p>
<ul class="simple">
<li><p>FOR <span class="math notranslate nohighlight">\(k=1\)</span> TO <span class="math notranslate nohighlight">\(m-2\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(x\gets A_{k+1:m,k}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(v_k\gets \mbox{sign}(x_1)\|x\|_2e_1 + x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(v_k\gets v_k/\|v\|_2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A_{k+1:m,k:m} \gets A_{k+1:m,k:m}- 2v_k(v_k^*A_{k+1:m,k:m})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A_{1:m,k+1:m} \gets A_{1:m,k+1:m}- 2(A_{1:m,k+1:m}v_k)v_k^*\)</span></p></li>
</ul>
</li>
<li><p>END FOR</p></li>
</ul>
<p>Note the similarities and differences with the Householder algorithm
for computing the QR factorisation.</p>
<div class="proof proof-type-exercise" id="id11">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.10</span>
        
    </div><div class="proof-content">
<p><span class="math notranslate nohighlight">\((\ddagger)\)</span> The <a class="reference internal" href="cla_utils.html#cla_utils.exercises8.hessenberg" title="cla_utils.exercises8.hessenberg"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises8.hessenberg()</span></code></a> function
has been left unimplemented. It should implement the algorithm
above, using only one loop over <span class="math notranslate nohighlight">\(k\)</span>. It should work “in-place”,
changing the input matrix. At the left multiplication, your
implementation should exploit the fact that zeros do not need to be
recomputed where there are already expected to be zeros. The test
script <code class="docutils literal notranslate"><span class="pre">test_exercises8.py</span></code> in the <code class="docutils literal notranslate"><span class="pre">test</span></code> directory will test
this function.</p>
</div></div><p>To calculate the operation count, we see that the algorithm is
dominated by the two updates to <span class="math notranslate nohighlight">\(A\)</span>, the first of which applies a
Householder reflection to rows from the left, and the second applies
the same reflections to columns from the right.</p>
<p>The left multiplication applies a Householder
reflection to the last <span class="math notranslate nohighlight">\(m-k\)</span> rows, requiring 4 FLOPs per
entry. However, these rows are zero in the first <span class="math notranslate nohighlight">\(k-1\)</span> columns,
so we can skip these and just work on the last <span class="math notranslate nohighlight">\(m-k+1\)</span> entries
of each of these rows.</p>
<p>Then, the total operation count for the left multiplication is</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[4 \times \sum_{k=1}^{m-1} (m-k)(m-k+1) \sim \frac{4}{3}m^3.\]</div>
</div></blockquote>
<p>The right multiplication does the same operations but now there are no
zeros to take advantage of, so all <span class="math notranslate nohighlight">\(m\)</span> entries in the each of the last
<span class="math notranslate nohighlight">\(m-k\)</span> columns need to be manipulated. With 4 FLOPs per entry, this becomes</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[4\times \sum_{k=1}^{m-1} m(m-k) \sim \frac{10}{3}m^3 FLOPs.\]</div>
</div></blockquote>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454123926" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>In the Hermitian case, the Hessenberg matrix becomes tridiagonal, and
these extra zeros can be exploited, leading to an operation count
<span class="math notranslate nohighlight">\(\sim 4m^3/3\)</span>.</p>
<p>It can be shown that this transformation to a Hessenberg matrix is
backwards stable, i.e. in a floating point implementation, it gives
<span class="math notranslate nohighlight">\(\tilde{Q},\tilde{H}\)</span> such that</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\tilde{Q}\tilde{H}\tilde{Q}^* = A + \delta A, \,
\frac{\|\delta A\|}{\|A\|}=\mathcal{O}(\varepsilon),\]</div>
</div></blockquote>
<p>for some <span class="math notranslate nohighlight">\(\delta A\)</span>.</p>
<div class="proof proof-type-exercise" id="id12">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.11</span>
        
    </div><div class="proof-content">
<p>The <a class="reference internal" href="cla_utils.html#cla_utils.exercises8.hessenbergQ" title="cla_utils.exercises8.hessenbergQ"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises8.hessenbergQ()</span></code></a> function
has been left unimplemented. It should implement the Hessenberg
algorithm again (you can just copy paste the code from the previous
exercise) but it should also return the matrix <span class="math notranslate nohighlight">\(Q\)</span> such that
<span class="math notranslate nohighlight">\(QHQ^*=A\)</span>. You need to work out how to alter the algorithm to
construct this. The test script <code class="docutils literal notranslate"><span class="pre">test_exercises8.py</span></code> in the
<code class="docutils literal notranslate"><span class="pre">test</span></code> directory will test this function.</p>
</div></div><div class="proof proof-type-exercise" id="id13">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.12</span>
        
    </div><div class="proof-content">
<p>The <a class="reference internal" href="cla_utils.html#cla_utils.exercises8.ev" title="cla_utils.exercises8.ev"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises8.ev()</span></code></a> function has been left
unimplemented. It should return the eigenvectors of
<span class="math notranslate nohighlight">\(A\)</span> by first reducing to Hessenberg form, using the functions you
have already created, and then calling
<a class="reference internal" href="cla_utils.html#cla_utils.exercises8.hessenberg_ev" title="cla_utils.exercises8.hessenberg_ev"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises8.hessenberg_ev()</span></code></a>, which computes the
eigenvectors of upper Hessenberg matrices (do not
edit this function!). The test script <code class="docutils literal notranslate"><span class="pre">test_exercises8.py</span></code> in the
<code class="docutils literal notranslate"><span class="pre">test</span></code> directory will test this function.</p>
</div></div><details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454124279" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>In the next few sections we develop the iterative part of the
transformation to the upper triangular matrix <span class="math notranslate nohighlight">\(T\)</span>. This algorithm
works for a broad class of matrices, but the explanation is much
easier for the case of real symmetric matrices, which have real
eigenvalues and orthogonals eigenvectors (which we shall normalise to
<span class="math notranslate nohighlight">\(\|q_i\|=1\)</span>, <span class="math notranslate nohighlight">\(i=1,2,\ldots,m\)</span>). The idea is that we will have already
transformed to Hessenberg form, which will be tridiagonal in this
case. Before describing the iterative transformation, we will discuss
a few key tools in explaining how it works.</p>
</section>
<section id="rayleigh-quotient">
<h2><span class="section-number">5.4. </span>Rayleigh quotient<a class="headerlink" href="#rayleigh-quotient" title="Permalink to this heading">¶</a></h2>
<p>The first tool that we shall consider is the Rayleigh quotient. If
<span class="math notranslate nohighlight">\(A\in \mathbb{C}^{m\times m}\)</span> is a real symmetric matrix, then the
Rayleigh quotient of a vector <span class="math notranslate nohighlight">\(x \in \mathbb{C}^{m}\)</span> is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[r(x) = \frac{x^TAx}{x^Tx}.\]</div>
</div></blockquote>
<p>If <span class="math notranslate nohighlight">\(x\)</span> is an eigenvector of <span class="math notranslate nohighlight">\(A\)</span>, then</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[r(x) = \frac{x^T\lambda x}{x^Tx} = \lambda,\]</div>
</div></blockquote>
<p>i.e. the Rayleigh quotient gives the corresponding eigenvalue.</p>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454124455" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>If <span class="math notranslate nohighlight">\(x\)</span> is not exactly an eigenvector of <span class="math notranslate nohighlight">\(A\)</span>, but is just close to one,
we might hope that <span class="math notranslate nohighlight">\(r(x)\)</span> is close to being an eigenvalue. To
investigate this we will consider the Taylor series expansion of
<span class="math notranslate nohighlight">\(r(x)\)</span> about an eigenvector <span class="math notranslate nohighlight">\(q_J\)</span> of <span class="math notranslate nohighlight">\(A\)</span>. We have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\nabla r(x) = \frac{2}{x^Tx}\left(Ax-r(x)x\right),\]</div>
</div></blockquote>
<p>which is zero when <span class="math notranslate nohighlight">\(x=q_J\)</span>, because then <span class="math notranslate nohighlight">\(r(q_J)=\lambda_J\)</span>:
eigenvectors of <span class="math notranslate nohighlight">\(A\)</span> are stationary points of <span class="math notranslate nohighlight">\(r(x)\)</span>! Hence, the Taylor
series has vanishing first order term,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[r(x) = r(q_J) + (x-q_J)^T\underbrace{\nabla r(q_J)}_{=0}
+ \mathcal{O}(\|x-q_J\|^2),\]</div>
</div></blockquote>
<p>i.e.</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[r(x) - r(q_J) = \mathcal{O}(\|x-q_J\|^2), \quad \mbox{as }
x \to q_J.\]</div>
</div></blockquote>
<p>The Rayleigh quotient gives a quadratically accurate estimate to the
eigenvalues of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="proof proof-type-exercise" id="id14">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.13</span>
        
    </div><div class="proof-content">
<p>Add a function to <a class="reference internal" href="cla_utils.html#module-cla_utils.exercises8" title="cla_utils.exercises8"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cla_utils.exercises8</span></code></a> that investigates
this property by:</p>
<ol class="arabic simple">
<li><p>Forming a Hermitian matrix <span class="math notranslate nohighlight">\(A\)</span>,</p></li>
<li><p>Finding an eigenvector <span class="math notranslate nohighlight">\(v\)</span> of <span class="math notranslate nohighlight">\(A\)</span> with eigenvalue <span class="math notranslate nohighlight">\(\lambda\)</span> (you can use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.eig.html#numpy.linalg.eig" title="(in NumPy v2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.linalg.eig()</span></code></a> for this),</p></li>
<li><p>Choosing a perturbation vector <span class="math notranslate nohighlight">\(r\)</span>, and perturbation parameter <span class="math notranslate nohighlight">\(\epsilon&gt;0\)</span>,</p></li>
<li><p>Comparing the Rayleigh quotient of <span class="math notranslate nohighlight">\(v + \epsilon r\)</span> with <span class="math notranslate nohighlight">\(\lambda\)</span>,</p></li>
<li><p>Plotting (on a log-log graph, use <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.loglog.html#matplotlib.pyplot.loglog" title="(in Matplotlib v3.9.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">matplotlib.pyplot.loglog()</span></code></a>) the error in estimating the eigenvalue as a function of <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
</ol>
<p>The best way to do this is to plot the computed data values as points,
and then superpose a line plot of <span class="math notranslate nohighlight">\(a\epsilon^k\)</span> for appropriate
value of <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(a\)</span> chosen so that the line appears not to far away
from the points on the same scale. This means that we can check
by eye if the error is scaling with <span class="math notranslate nohighlight">\(\epsilon\)</span> at the expected rate.</p>
</div></div></section>
<section id="power-iteration">
<h2><span class="section-number">5.5. </span>Power iteration<a class="headerlink" href="#power-iteration" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454124701" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>Power iteration is a simple method for finding the eigenvalue of
<span class="math notranslate nohighlight">\(A\)</span> with largest eigenvalue (in magnitude). It is based on the following
idea. We expand a vector <span class="math notranslate nohighlight">\(v\)</span> in eigenvectors of <span class="math notranslate nohighlight">\(A\)</span>,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[v = a_1q_1 + a_2q_2 + \ldots a_mq_m,\]</div>
</div></blockquote>
<p>where we have ordered the eigenvalues so that <span class="math notranslate nohighlight">\(|\lambda_1|\geq |\lambda_2|
\geq |\lambda 3| \geq \ldots \geq |\lambda_m\)</span>.</p>
<p>Then,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[Av = a_1\lambda_1q_1 + a_2\lambda_2q_2 + \ldots a_m\lambda_m q_m,\]</div>
</div></blockquote>
<p>and hence, repeated applications of <span class="math notranslate nohighlight">\(A\)</span> gives</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}A^kv = \underbrace{AA\ldots A}_{k\mbox{ times}}v\\= a_1\lambda^k_1q_1 + a_2\lambda^k_2q_2 + \ldots a_m\lambda^k_m q_m.\end{aligned}\end{align} \]</div>
</div></blockquote>
<p>If <span class="math notranslate nohighlight">\(|\lambda_1|&gt;|\lambda_2|\)</span>, then provided that <span class="math notranslate nohighlight">\(a_1=q_1^Tv\neq 0\)</span>,
the first term <span class="math notranslate nohighlight">\(a_1\lambda^k_1q_1\)</span> rapidly becomes larger than all of
the others, and so <span class="math notranslate nohighlight">\(A^kv \approx a_1\lambda^k_1 q_1\)</span>, and we can
normalise to get <span class="math notranslate nohighlight">\(q_1 \approx A^kv/\|A^kv\|\)</span>. To keep the magnitude of
the estimate from getting too large or small (depending on the size of
<span class="math notranslate nohighlight">\(\lambda_1\)</span> relative to 1), we can alternately apply <span class="math notranslate nohighlight">\(A\)</span> and normalise,
which gives the power iteration. Along the way, we can use the Rayleigh
quotient to see how our approximation of the eigenvalue is going.</p>
<ul class="simple">
<li><p>Set <span class="math notranslate nohighlight">\(v_0\)</span> to some initial vector (hoping that <span class="math notranslate nohighlight">\(\|q_1^Tv_0\|&gt;0\)</span>).</p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(w\gets Av^{k-1}\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(v^k\gets w/\|w\|\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda^{(k)} \gets (v^k)^TAv^k\)</span>.</p></li>
</ul>
</li>
</ul>
<p>Here we have used the fact that <span class="math notranslate nohighlight">\(\|v^k\|=1\)</span>, so there is no need to
divide by it in the Rayleigh quotient. We terminate the power
iteration when we decide that the changes in <span class="math notranslate nohighlight">\(\lambda\)</span> indicate
that the error is small. This is guided by the following result.</p>
<div class="proof proof-type-theorem" id="id15">
<span id="id1"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 5.14</span>
        
    </div><div class="proof-content">
<p>If <span class="math notranslate nohighlight">\(|\lambda_1|&gt; |\lambda_2|\)</span> and <span class="math notranslate nohighlight">\(\|q_1^Tv_0\|&gt;0\)</span>, then after
<span class="math notranslate nohighlight">\(k\)</span> iterations of power iteration, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\|v^k - \pm q_1\| = \mathcal{O}\left(
\left|\frac{\lambda_2}{\lambda_1}\right|^k\right),
\quad |\lambda^{(k)} - \lambda_1|=
\mathcal{O}\left(\left|\frac{\lambda_2}{\lambda_1}\right|^{2k}\right),\]</div>
</div></blockquote>
<p>as <span class="math notranslate nohighlight">\(k\to\infty\)</span>. At each step <span class="math notranslate nohighlight">\(\pm\)</span> we mean that the result holds
for either <span class="math notranslate nohighlight">\(+\)</span> or <span class="math notranslate nohighlight">\(-\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>We have already shown the first equation using the Taylor series, and
the second equation comes by combining the Taylor series error with
the Rayleigh quotient error.</p>
</div></div><p>The <span class="math notranslate nohighlight">\(\pm\)</span> feature is a bit annoying, and relates to the fact that the
normalisation does not select <span class="math notranslate nohighlight">\(v^k\)</span> to have the direction as <span class="math notranslate nohighlight">\(q_1\)</span>.</p>
<div class="proof proof-type-exercise" id="id16">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.15</span>
        
    </div><div class="proof-content">
<p>The <a class="reference internal" href="cla_utils.html#cla_utils.exercises9.pow_it" title="cla_utils.exercises9.pow_it"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.pow_it()</span></code></a> function has
been left unimplemented. It should apply power iteration to a given
matrix and initial vector, according to the docstring. The test
script <code class="docutils literal notranslate"><span class="pre">test_exercises9.py</span></code> in the <code class="docutils literal notranslate"><span class="pre">test</span></code> directory will test
this function.</p>
</div></div><div class="proof proof-type-exercise" id="id17">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.16</span>
        
    </div><div class="proof-content">
<p>The functions <code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.A3()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.B3()</span></code> each return a 3x3 matrix, <span class="math notranslate nohighlight">\(A_3\)</span> and
<span class="math notranslate nohighlight">\(B_3\)</span> respectively. Apply <a class="reference internal" href="cla_utils.html#cla_utils.exercises9.pow_it" title="cla_utils.exercises9.pow_it"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.pow_it()</span></code></a> to
each of these functions. What differences in behaviour do you
observe? What is it about <span class="math notranslate nohighlight">\(A_3\)</span> and <span class="math notranslate nohighlight">\(B_3\)</span> that causes this?</p>
</div></div></section>
<section id="inverse-iteration">
<h2><span class="section-number">5.6. </span>Inverse iteration<a class="headerlink" href="#inverse-iteration" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454124799" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>Inverse iteration is a modification of power iteration so that we can
find eigenvalues other than <span class="math notranslate nohighlight">\(\lambda_1\)</span>. To do this, we use the fact
that eigenvectors <span class="math notranslate nohighlight">\(q_j\)</span> of <span class="math notranslate nohighlight">\(A\)</span> are also eigenvectors of <span class="math notranslate nohighlight">\((A - \mu
I)^{-1}\)</span> for any <span class="math notranslate nohighlight">\(\mu\in \mathbb{R}\)</span> not an eigenvalue of <span class="math notranslate nohighlight">\(A\)</span>
(otherwise <span class="math notranslate nohighlight">\(A-\mu I\)</span> is singular). To show this, we write</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[(A - \mu I)q_j = (\lambda_j - \mu)q_j
\implies (A - \mu I)^{-1}q_j = \frac{1}{\lambda_j - \mu}q_j.\]</div>
</div></blockquote>
<p>Thus <span class="math notranslate nohighlight">\(q_j\)</span> is an eigenvalue of <span class="math notranslate nohighlight">\((A - \mu I)^{-1}\)</span> with eigenvalue
<span class="math notranslate nohighlight">\(1/(\lambda_j - \mu)\)</span>. We can then apply power iteration to <span class="math notranslate nohighlight">\((A-\mu
I)^{-1}\)</span> (which requires a matrix solve per iteration), which
converges to an eigenvector <span class="math notranslate nohighlight">\(q\)</span> for which <span class="math notranslate nohighlight">\(1/|\lambda-\mu|\)</span> is
smallest, where <span class="math notranslate nohighlight">\(\lambda\)</span> is the corresponding eigenvalue. In other
words, we will find the eigenvector of <span class="math notranslate nohighlight">\(A\)</span> whose eigenvalue is closest
to <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<p>This algorithm is called inverse iteration, which we express in
pseudo-code below.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(v^{0}\gets\)</span> some initial vector with <span class="math notranslate nohighlight">\(\|v^0\|=1\)</span>.</p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p>SOLVE <span class="math notranslate nohighlight">\((A-\mu I)w = v^{k-1}\)</span> for <span class="math notranslate nohighlight">\(w\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(v^k\gets w/\|w\|\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda^{(k)} \gets (v^k)^TAv^k\)</span></p></li>
</ul>
</li>
</ul>
<p>We can then directly extend <a class="reference internal" href="#id1"><span class="std std-numref">Theorem
5.14</span></a> to the inverse iteration algorithm.
We conclude that the convergence rate is not improved relative
to power iteration, but now we can “dial in” to different
eigenvalues by choosing <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<div class="proof proof-type-exercise" id="id18">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.17</span>
        
    </div><div class="proof-content">
<p>The <a class="reference internal" href="cla_utils.html#cla_utils.exercises9.inverse_it" title="cla_utils.exercises9.inverse_it"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.inverse_it()</span></code></a> function
has been left unimplemented. It should apply inverse iteration to a
given matrix and initial vector, according to the docstring. The
test script <code class="docutils literal notranslate"><span class="pre">test_exercises9.py</span></code> in the <code class="docutils literal notranslate"><span class="pre">test</span></code> directory will
test this function.</p>
</div></div><div class="proof proof-type-exercise" id="id19">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.18</span>
        
    </div><div class="proof-content">
<p>Using the <span class="math notranslate nohighlight">\(A_3\)</span> and <span class="math notranslate nohighlight">\(B_3\)</span> matrices, explore the inverse iteration
using different values of <span class="math notranslate nohighlight">\(\mu\)</span>. What do you observe?</p>
</div></div></section>
<section id="rayleigh-quotient-iteration">
<h2><span class="section-number">5.7. </span>Rayleigh quotient iteration<a class="headerlink" href="#rayleigh-quotient-iteration" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454303115" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>Since we can use the Rayleigh quotient to find an approximation of an
eigenvalue, and we can use an approximation of an eigenvalue to find
the nearest eigenvalue using inverse iteration, we can combine them
together. The idea is to start with a vector, compute the Rayleigh
quotient, use the Rayleigh quotient for <span class="math notranslate nohighlight">\(\mu\)</span>, then do one step of
inverse iteration to give an updated vector which should now be closer
to an eigenvector. Then we iterate this whole process. This is called
the Rayleigh quotient iteration, which we express in pseudo-code
below.</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(v^{0}\)</span> some initial vector with <span class="math notranslate nohighlight">\(\|v^0\|=1\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda^{(0)} \gets (v^0)^TAv^0\)</span></p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p>SOLVE <span class="math notranslate nohighlight">\((A-\lambda^{(k-1)} I)w = v^{k-1}\)</span> for <span class="math notranslate nohighlight">\(w\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(v^k\gets w/\|w\|\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda^{(k)} \gets (v^k)^TAv^k\)</span></p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>This dramatically improves the convergence since if
<span class="math notranslate nohighlight">\(\|v^k-q_J\|=\mathcal{O}(\delta)\)</span> for some small <span class="math notranslate nohighlight">\(\delta\)</span>, then the
Rayleigh quotient gives <span class="math notranslate nohighlight">\(|\lambda^{(k)}-q_J|=\mathcal{O}(\delta^2)\)</span>.
Then, inverse iteration gives an estimate</p>
<div class="math notranslate nohighlight">
\[\|v^{k+1}-\pm q_J\| = \mathcal{O}(|\lambda^{(k)}-\lambda_J|
\|v^k-q_J\|) = \mathcal{O}(\delta^3).\]</div>
<p>Thus we have cubic convergence, which is super fast!</p>
<div class="proof proof-type-exercise" id="id20">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.19</span>
        
    </div><div class="proof-content">
<p>The <a class="reference internal" href="cla_utils.html#cla_utils.exercises9.rq_it" title="cla_utils.exercises9.rq_it"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.rq_it()</span></code></a> function has
been left unimplemented. It should apply inverse iteration to a
given matrix and initial vector, according to the docstring. The
test script <code class="docutils literal notranslate"><span class="pre">test_exercises9.py</span></code> in the <code class="docutils literal notranslate"><span class="pre">test</span></code> directory will
test this function.</p>
</div></div><div class="proof proof-type-exercise" id="id21">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.20</span>
        
    </div><div class="proof-content">
<p>The interfaces to <a class="reference internal" href="cla_utils.html#cla_utils.exercises9.inverse_it" title="cla_utils.exercises9.inverse_it"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.inverse_it()</span></code></a> and
<a class="reference internal" href="cla_utils.html#cla_utils.exercises9.rq_it" title="cla_utils.exercises9.rq_it"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.rq_it()</span></code></a> have been designed to optionally
provide the iterated values of the eigenvector and eigenvalue.  For
a given initial condition (and choice of <span class="math notranslate nohighlight">\(\mu\)</span> in the case of
inverse iteration), compare the convergence speeds of the
eigenvectors and eigenvalues, using some example matrices of
different sizes (don’t forget to make them Hermitian).</p>
</div></div></section>
<section id="the-pure-qr-algorithm">
<h2><span class="section-number">5.8. </span>The pure QR algorithm<a class="headerlink" href="#the-pure-qr-algorithm" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454124953" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>We now describe the QR algorithm, which will turn out to be an
iterative algorithm that converges to the diagonal matrix (upper
triangular matrix for the general nonsymmetric case) that <span class="math notranslate nohighlight">\(A\)</span> is
similar to. Why this works is not at all obvious at first, and
we shall explain this later. For now, here is the algorithm
written as pseudo-code.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A^{(0)} \gets A\)</span></p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p>FIND <span class="math notranslate nohighlight">\(Q^{(k)},R^{(k)}\)</span> such that <span class="math notranslate nohighlight">\(Q^{(k)}R^{(k)}=A^{(k-1)}\)</span> (USING QR FACTORISATION)</p></li>
<li><p><span class="math notranslate nohighlight">\(A^{(k)} = R^{(k)}Q^{(k)}\)</span></p></li>
</ul>
</li>
</ul>
<div class="proof proof-type-exercise" id="id22">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.21</span>
        
    </div><div class="proof-content">
<p><span class="math notranslate nohighlight">\((\ddagger)\)</span> The <a class="reference internal" href="cla_utils.html#cla_utils.exercises9.pure_QR" title="cla_utils.exercises9.pure_QR"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.pure_QR()</span></code></a> function has
been left unimplemented. It should implement the pure QR algorithm
as above, using your previous code for finding the QR factorisation
using Householder transformations. You should think about avoiding
unecessary allocation of new numpy arrays inside the loop. The
method of testing for convergence has been left as well. Have a
think about how to do this and document your implementation. The
test script <code class="docutils literal notranslate"><span class="pre">test_exercises9.py</span></code> in the <code class="docutils literal notranslate"><span class="pre">test</span></code> directory will
test this function.</p>
</div></div><div class="proof proof-type-exercise" id="id23">

    <div class="proof-title">
        <span class="proof-type">Exercise 5.22</span>
        
    </div><div class="proof-content">
<p>Investigate the behaviour of the pure QR algorithm applied to the
functions provided by <a class="reference internal" href="cla_utils.html#cla_utils.exercises9.get_A100" title="cla_utils.exercises9.get_A100"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.get_A100()</span></code></a>,
<a class="reference internal" href="cla_utils.html#cla_utils.exercises9.get_B100" title="cla_utils.exercises9.get_B100"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.get_B100()</span></code></a>,
<a class="reference internal" href="cla_utils.html#cla_utils.exercises9.get_C100" title="cla_utils.exercises9.get_C100"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.get_C100()</span></code></a>, and
<a class="reference internal" href="cla_utils.html#cla_utils.exercises9.get_D100" title="cla_utils.exercises9.get_D100"><code class="xref py py-func docutils literal notranslate"><span class="pre">cla_utils.exercises9.get_D100()</span></code></a>. You can use
<a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.pcolor.html#matplotlib.pyplot.pcolor" title="(in Matplotlib v3.9.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">matplotlib.pyplot.pcolor()</span></code></a> to visualise the entries,
or compute norms of the components of the matrices below the diagonal,
for example. What do you observe? How does this relate to the structure
of the four matrices?</p>
</div></div><p>The algorithm simply finds the QR factorisation of <span class="math notranslate nohighlight">\(A\)</span>, swaps Q and R,
and repeats. We call this algorithm the “pure” QR algorithm, since it
can be accelerated with some modifications that comprise the
“practical” QR algorithm that is used in practice.</p>
<p>We can at least see that this is computing similarity transformations since</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A^{(k)} = R^{(k)}Q^{(k)} = (Q^{(k)})^*Q^{(k)}R^{(k)}Q^{(k)} = (Q^{(k)})^*A^{(k-1)}Q^{(k)},\]</div>
</div></blockquote>
<p>so that <span class="math notranslate nohighlight">\(A^{(k)}\)</span> is similar to <span class="math notranslate nohighlight">\(A^{(k-1)}\)</span> and hence to <span class="math notranslate nohighlight">\(A^{(k-2)}\)</span> and all
the way back to <span class="math notranslate nohighlight">\(A\)</span>. But why does <span class="math notranslate nohighlight">\(A^{(k)}\)</span> converge to a diagonal matrix?
To see this, we have to show that the QR algorithm is equivalent to
another algorithm called simultaneous iteration.</p>
</section>
<section id="simultaneous-iteration">
<h2><span class="section-number">5.9. </span>Simultaneous iteration<a class="headerlink" href="#simultaneous-iteration" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454125180" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>One problem with power iteration is that it only finds one
eigenvector/eigenvalue pair at a time. Simultaneous iteration is a
solution to this. The starting idea is simple: instead of working on
just one vector <span class="math notranslate nohighlight">\(v\)</span>, we pick a set of linearly independent vectors
<span class="math notranslate nohighlight">\(v_1^{0},v_2^{0},\ldots,v_n^{0}\)</span> and repeatedly apply <span class="math notranslate nohighlight">\(A\)</span> to each of
these vectors. After a large number applications and normalisations in
the manner of the power iteration, we end up with a linear independent
set <span class="math notranslate nohighlight">\(v_1^{k},v_2^{k},\ldots,v_n^{k}\)</span>, <span class="math notranslate nohighlight">\(n\leq m\)</span>. All of the vectors in this set
will be very close to <span class="math notranslate nohighlight">\(q_1\)</span>, the eigenvector with largest magnitude of
corresponding eigenvalue. We can choose <span class="math notranslate nohighlight">\(v_1^{k}\)</span> as our approximation
of <span class="math notranslate nohighlight">\(q_1\)</span>, and project this approximation of <span class="math notranslate nohighlight">\(q_1\)</span> from the rest of the
vectors <span class="math notranslate nohighlight">\(v_2^{k},v_3^{k},\ldots v_m^{k}\)</span>.  All the remaining vectors
will be close to <span class="math notranslate nohighlight">\(q_2\)</span>, the eigenvector with the next largest
magnitude of corresponding eigenvalue. Similarly we can choose the
first one of the remaining projected vectors as an approximation of
<span class="math notranslate nohighlight">\(q_2\)</span> and project it again from the rest.</p>
<p>We can translate this idea to matrices by defining <span class="math notranslate nohighlight">\(V^{(0)}\)</span> to be the
matrix with columns given by the set of initial <span class="math notranslate nohighlight">\(v\)</span> s. Then after <span class="math notranslate nohighlight">\(k\)</span>
applications of <span class="math notranslate nohighlight">\(A\)</span>, we have <span class="math notranslate nohighlight">\(V^{(k)}=A^{k} V^{(0)}\)</span>. By the column space
interpretation of matrix-matrix multiplication, each column of <span class="math notranslate nohighlight">\(V^{(k)}\)</span>
is <span class="math notranslate nohighlight">\(A^{k}\)</span> multiplied by the corresponding column of <span class="math notranslate nohighlight">\(V^{(0)}\)</span>. To make the
normalisation and projection process above, we could just apply the
Gram-Schmidt algorithm, sequentially forming an orthonormal spanning
set for the columns of <span class="math notranslate nohighlight">\(V^{(k)}\)</span> working from left to right.  However, we
know that an equivalent way to do this is to form the (reduced) QR
factorisation of <span class="math notranslate nohighlight">\(V^{(k)}\)</span>, <span class="math notranslate nohighlight">\(\hat{Q}^{(k)}\hat{R}^{(k)}=V^{(k)}\)</span>; the columns of
<span class="math notranslate nohighlight">\(\hat{Q}^{(k)}\)</span> give the same orthonormal spanning set.  Hence, the
columns of <span class="math notranslate nohighlight">\(\hat{Q}^{(k)}\)</span> will converge to eigenvectors of <span class="math notranslate nohighlight">\(A\)</span>, provided
that:</p>
<ol class="arabic simple">
<li><p>The first <span class="math notranslate nohighlight">\(n\)</span> eigenvalues of <span class="math notranslate nohighlight">\(A\)</span> are distinct in absolute value:
<span class="math notranslate nohighlight">\(|\lambda_1| &gt; |\lambda_2| &gt; \ldots &gt; |\lambda_n|\)</span>. If we want to find
all of the eigenvalues <span class="math notranslate nohighlight">\(n=m\)</span>, then all the absolute values of the
eigenvalues must be distinct.</p></li>
<li><p>The <span class="math notranslate nohighlight">\(v\)</span> vectors can be expressed as a linear sum of the first <span class="math notranslate nohighlight">\(n\)</span>
eigenvectors <span class="math notranslate nohighlight">\(q_1,\ldots,q_n\)</span> in a non-degenerate way. This turns
out  to be equivalent (we won’t show it here) to the condition that
<span class="math notranslate nohighlight">\(\hat{Q}^TV^{(0)}\)</span> has an LU factorisation (where <span class="math notranslate nohighlight">\(\hat{Q}\)</span> is the
matrix whose columns are the first <span class="math notranslate nohighlight">\(n\)</span> eigenvectors of <span class="math notranslate nohighlight">\(A\)</span>).</p></li>
</ol>
<p>One problem with this idea is that it is not numerically stable.  The
columns of <span class="math notranslate nohighlight">\(V^{(k)}\)</span> rapidly become a very ill-conditioned basis for the
spanning space of the original independent set, and the values of
eigenvectors will be quickly engulfed in rounding errors. There is a
simple solution to this though, which is to orthogonalise after
each application of <span class="math notranslate nohighlight">\(A\)</span>. This is the simultaneous iteration algorithm,
which we express in the following pseudo-code.</p>
<ul class="simple">
<li><p>TAKE A UNITARY MATRIX <span class="math notranslate nohighlight">\(\hat{Q}^{(0)}\)</span></p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(Z\gets A\hat{Q}^{(k-1)}\)</span></p></li>
<li><p>FIND <span class="math notranslate nohighlight">\(Q^{(k)},R^{(k)}\)</span> such that <span class="math notranslate nohighlight">\(Q^{(k)}R^{(k)}=Z\)</span> (USING QR FACTORISATION)</p></li>
</ul>
</li>
</ul>
<p>This is mathematically equivalent to the process we described above,
and so it converges under the same two conditions listed above.</p>
<p>We can already see that this looks rather close to the QR algorithm.
The following section confirms that they are in fact equivalent.</p>
</section>
<section id="the-pure-qr-algorithm-and-simultaneous-iteration-are-equivalent">
<h2><span class="section-number">5.10. </span>The pure QR algorithm and simultaneous iteration are equivalent<a class="headerlink" href="#the-pure-qr-algorithm-and-simultaneous-iteration-are-equivalent" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454125393" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>To be precise, we will show that the pure QR algorithm is equivalent
to simultaneous iteration when the initial independent set is the
canonical basis <span class="math notranslate nohighlight">\(I\)</span>, i.e. <span class="math notranslate nohighlight">\(Q^{(0)}=I\)</span>. From the above, we see that
that algorithm converges provided that <span class="math notranslate nohighlight">\(Q^T\)</span> has an LU decomposition,
where <span class="math notranslate nohighlight">\(Q\)</span> is the limiting unitary matrix that simultaneous iteration
is converging to.  To show that the two algorithms are equivalent, we
append them with some auxiliary variables, which are not needed for
the algorithms but are needed for the comparison.</p>
<p>To simultaneous iteration we append a running similarity transformation
of <span class="math notranslate nohighlight">\(A\)</span>, and a running product of all of the <span class="math notranslate nohighlight">\(R\)</span> matrices.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\({Q'}^{(0)} \gets I\)</span></p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(Z\gets A{Q'}^{(k-1)}\)</span></p></li>
<li><p>FIND <span class="math notranslate nohighlight">\({Q'}^{(k)},R^{(k)}\)</span> such that <span class="math notranslate nohighlight">\({Q'}^{(k)}R^{(k)}=Z\)</span> (USING QR FACTORISATION)</p></li>
<li><p><span class="math notranslate nohighlight">\(A^{(k)} = ({Q'}^{(k)})^TA{Q'}^{(k)}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\({R'}^{(k)} = R^{(k)}R^{(k-1)}\ldots R^{(1)}\)</span></p></li>
</ul>
</li>
</ul>
<p>To the pure QR factorisation we append a running product of the <span class="math notranslate nohighlight">\(Q^{k}\)</span>
matrices, and a running product of all of the <span class="math notranslate nohighlight">\(R\)</span> matrices (again).</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A^{(0)} \gets A\)</span></p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p>FIND <span class="math notranslate nohighlight">\(Q^{(k)},R^{(k)}\)</span> such that <span class="math notranslate nohighlight">\(Q^{(k)}R^{(k)}=A^{(k-1)}\)</span> (USING QR FACTORISATION)</p></li>
<li><p><span class="math notranslate nohighlight">\(A^{(k)} = R^{(k)}Q^{(k)}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\({Q'}^{(k)} = Q^{(1)}Q^{(2)}\ldots Q^{(k)}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\({R'}^{(k)} = R^{(k)}R^{(k-1)}\ldots R^{(1)}\)</span></p></li>
</ul>
</li>
</ul>
<div class="proof proof-type-theorem" id="id24">

    <div class="proof-title">
        <span class="proof-type">Theorem 5.23</span>
        
            <span class="proof-title-name">(pure QR and simultaneous iteration with <span class="math notranslate nohighlight">\(I\)</span> are equivalent)</span>
        
    </div><div class="proof-content">
<p>The two processes above generate identical sequences of matrices
<span class="math notranslate nohighlight">\({R'}^{(k)}\)</span>, <span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span> and <span class="math notranslate nohighlight">\(A^{(k)}\)</span>, which are related by
<span class="math notranslate nohighlight">\(A^{k} = {Q'}^{(k)}{R'}^{(k)}\)</span> (the <span class="math notranslate nohighlight">\(k\)</span>-th power of <span class="math notranslate nohighlight">\(A\)</span>, not
<span class="math notranslate nohighlight">\(A^{(k)}\)</span>!), and <span class="math notranslate nohighlight">\(A^{(k)}=({Q'}^{(k)})^TA{Q'}^{(k)}\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>We prove by induction. At <span class="math notranslate nohighlight">\(k=0\)</span>, <span class="math notranslate nohighlight">\(A_k={R'}^{(k)}={Q'}^{(k)}=I\)</span>. Now
we assume that the inductive hypothesis is true for <span class="math notranslate nohighlight">\(k\)</span>, and aim to
deduce that it is true for <span class="math notranslate nohighlight">\(k+1\)</span>.</p>
<p>For simultaneous iteration, we immediately have the simularity
formula for <span class="math notranslate nohighlight">\(A^{(k)}\)</span> by definition, and we just need to verify the QR
factorisation of <span class="math notranslate nohighlight">\(A^k\)</span>. From the inductive hypothesis,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A^k = AA^{k-1} = A{Q'}^{(k-1)}{R'}^{(k-1)}
= Z{R'}^{(k-1)} = {Q'}^{(k)}\underbrace{R^{(k)}{R'}^{(k-1)}}_{={R'}^{(k)}}
= {Q'}^{(k)}{R'}^{(k)},\]</div>
</div></blockquote>
<p>as required (using the definition of <span class="math notranslate nohighlight">\(Z\)</span> and then the definition of
<span class="math notranslate nohighlight">\({R'}^{(k)}\)</span>).</p>
<p>For the QR algorithm, we again use the inductive hypothesis on the
QR factorization of <span class="math notranslate nohighlight">\(A^k\)</span> followed by the inductive hypothesis on
the similarity transform to get</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A^k = AA^{k-1} =A{Q'}^{(k-1)}{R'}^{(k-1)}
= {Q'}^{(k-1)}A^{(k-1)}{R'}^{(k-1)} =
{Q'}^{(k-1)}Q^{(k)}R^{(k)}{R'}^{(k-1)}
= {Q'}^{(k)}{R'}^{(k)},\]</div>
</div></blockquote>
<p>where we used the algorithm definitions in the third equality and
then the definitions of <span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span> and <span class="math notranslate nohighlight">\({R'}^{(k)}\)</span>. To verify
the similarity transform at iteration <span class="math notranslate nohighlight">\(k\)</span> we use the algorithm definitions
to write</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A^{(k)} = R^{(k)}Q^{(k)} = (Q^{(k)})^TQ^{(k)}R^{(k)}Q^{(k)}
= ({Q'}^{(k)})^TA({Q'})^{(k)},\]</div>
</div></blockquote>
<p>as required.</p>
</div></div><p>This theorem tells us that the QR algorithm will converge under the
conditions that simultaneous iteration converges. It also tells us
that the QR algorithm finds an orthonormal basis (the columns of
<span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span>) from the columns of each power of <span class="math notranslate nohighlight">\(A^k\)</span>; this is how
it relates to power iteration.</p>
</section>
<section id="connections-between-power-iteration-inverse-iteration-and-qr-algorithm">
<h2><span class="section-number">5.11. </span>Connections between power iteration, inverse iteration, and QR algorithm<a class="headerlink" href="#connections-between-power-iteration-inverse-iteration-and-qr-algorithm" title="Permalink to this heading">¶</a></h2>
<p>There are some subtle connections between these algorithms that we can
exploit to accelerate the convergence of the QR algorithm. After <span class="math notranslate nohighlight">\(k\)</span>
iterations we have</p>
<div class="math notranslate nohighlight">
\[A^k = {Q'}^{(k)}{R'}^{(k)},\]</div>
<p>from the above theorem. (Remember that <span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span> and <span class="math notranslate nohighlight">\({R'}^{(k)}\)</span>,
are different from <span class="math notranslate nohighlight">\({Q}^{(k)}\)</span> and <span class="math notranslate nohighlight">\({R}^{(k)}\)</span>.)  In particular, the
first column of <span class="math notranslate nohighlight">\({R'}^{(k)}\)</span> is <span class="math notranslate nohighlight">\(e_1r_{11}^{(k)}\)</span> (because <span class="math notranslate nohighlight">\({R'}^{(k)}\)</span> is
an upper triangular matrix), so the first column of <span class="math notranslate nohighlight">\(A^k\)</span> is</p>
<div class="math notranslate nohighlight">
\[A^ke_1 = r_{11}^{(k)}{Q'}^{(k)}e_1.\]</div>
<p>In other words, the first column of <span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span> is the result of <span class="math notranslate nohighlight">\(k\)</span>
iterations of power iteration starting at <span class="math notranslate nohighlight">\(e_1\)</span>. (We already knew this
from the previous theorem, but here we are introducing ways to look at
different components of <span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span> and <span class="math notranslate nohighlight">\({R'}^{(k)}\)</span>). This means that
it will converge to the eigenvector of <span class="math notranslate nohighlight">\(A\)</span> with the eigenvalue of
largest magnitude, and the convergence rate will depend on the gap
between the magnitude of that eigenvalue and the magnitude of the next
largest.</p>
<p>To look at connections with inverse iteration, we use the inverse formula,</p>
<div class="math notranslate nohighlight">
\[A^{-k} = \left({R'}^{(k)}\right)^{-1}\left({Q'}^{(k)}\right)^* :=
{\tilde{R}}^{(k)}\left({Q'}^{(k)}\right)^*,\]</div>
<p>where <span class="math notranslate nohighlight">\({\tilde{R}}^{(k)}=\left({R'}^{(k)}\right)^{-1}\)</span> is also upper
triangular since invertible upper triangular matrices form a group.</p>
<p>Then,</p>
<div class="math notranslate nohighlight">
\[(A^{-k})^T =
{Q'}^{(k)}({\tilde{R}}^{(k)})^T.\]</div>
<p>The last column of <span class="math notranslate nohighlight">\(({\tilde{R}}^{(k)})^T\)</span> is <span class="math notranslate nohighlight">\(\tilde{r}^{(k)}_{nn}e_n\)</span>,
so the last column of <span class="math notranslate nohighlight">\((A^{-k})^T\)</span> is</p>
<div class="math notranslate nohighlight">
\[(A^{-k})^Te_n = {Q'}^{(k)}\tilde{r}_{nn} e_n,\]</div>
<p>i.e. the last column of <span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span> corresponds to the <span class="math notranslate nohighlight">\(k\)</span> th step of
inverse iteration applied to <span class="math notranslate nohighlight">\(A^T\)</span>. When <span class="math notranslate nohighlight">\(A\)</span> is symmetric, this is the
same as inverse iteration applied to <span class="math notranslate nohighlight">\(e_n\)</span>.</p>
</section>
<section id="the-practical-qr-algorithm">
<h2><span class="section-number">5.12. </span>The practical QR algorithm<a class="headerlink" href="#the-practical-qr-algorithm" title="Permalink to this heading">¶</a></h2>
<details>
<summary>
Supplementary video</summary><div class="video_wrapper" style="">
<iframe allowfullscreen="true" src="https://player.vimeo.com/video/454125822" style="border: 0; height: 345px; width: 560px">
</iframe></div></details><p>The practical QR algorithm for real symmetric matrices has a number of
extra elements that make it fast. First, recall that we start by
transforming to tridiagonal (symmetric Hessenberg) form. This cuts
down the numerical cost of the steps of the QR algorithm.</p>
<p>For the second element, the Rayleigh quotient algorithm idea is
incorporated by applying shifts <span class="math notranslate nohighlight">\(A^{(k)}-\mu^{(k)}I\)</span>, where
<span class="math notranslate nohighlight">\(\mu^{(k)}\)</span> is some eigenvalue estimate for the smallest
eigenvalues. Relying on the fact that if <span class="math notranslate nohighlight">\(A\)</span> is symmetric, then we
know that the last diagonal in <span class="math notranslate nohighlight">\(R^{(k)}\)</span> will be converging to the
smallest eigenvalue of <span class="math notranslate nohighlight">\(A\)</span> via inverse iteration. Then, applying QR to
the shifted matrix, the last diagonal will converge to the eigenvalue
of <span class="math notranslate nohighlight">\(A\)</span> closest to <span class="math notranslate nohighlight">\(\mu^{(k)}\)</span>. This will happen quickly if <span class="math notranslate nohighlight">\(\mu^{(k)}\)</span>
is an accurate estimate of an eigenvalue of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>For the third element, when an eigenvalue is found (i.e. an eigenvalue
appears accurately on the diagonal of <span class="math notranslate nohighlight">\(A^{(k)}\)</span>) the off-diagonal
components are very small, and the matrix decouples into a block
diagonal matrix where the QR algorithm can be independently applied to
the blocks (which is cheaper than doing them all together). This final
idea is called deflation.</p>
<p>A sketch of the practical QR algorithm is as follows.</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(A^{(0)} \gets\)</span> TRIDIAGONAL MATRIX</p></li>
<li><p>FOR <span class="math notranslate nohighlight">\(k=1,2,\ldots\)</span></p>
<ul>
<li><p>PICK A SHIFT <span class="math notranslate nohighlight">\(\mu^{(k)}\)</span> (discussed below)</p></li>
<li><p><span class="math notranslate nohighlight">\(Q^{(k)}R^{(k)} = A^{(k-1)} - \mu^{(k)}I\)</span> (from QR factorisation)</p></li>
<li><p><span class="math notranslate nohighlight">\(A^{(k)} = R^{(k)}Q^{(k)} + \mu^{(k)}I\)</span></p></li>
<li><p>IF <span class="math notranslate nohighlight">\(A^{(k)}_{j,j+1}\approx 0\)</span> FOR SOME <span class="math notranslate nohighlight">\(j\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(A_{j,j+1}\gets 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A_{j+1,j}\gets 0\)</span></p></li>
<li><p>continue by applying the practical QR algorithm to
the diagonal blocks <span class="math notranslate nohighlight">\(A_1\)</span> and <span class="math notranslate nohighlight">\(A_2\)</span> of</p>
<div class="math notranslate nohighlight">
\[\begin{split}A_k =
\begin{pmatrix}
A_1 &amp; 0 \\
0 &amp; A_2 \\
\end{pmatrix}\end{split}\]</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>One possible way to select the shift <span class="math notranslate nohighlight">\(\mu^{(k)}\)</span> is to calculate a
Rayleigh quotient with <span class="math notranslate nohighlight">\(A\)</span> using the last column <span class="math notranslate nohighlight">\(q_m^{(k)}\)</span> of <span class="math notranslate nohighlight">\({Q'}^{(k)}\)</span>,
which then gives cubic convergence for this eigenvector and
eigenvalue. In fact, this is just <span class="math notranslate nohighlight">\(A_{mm}^k\)</span>,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A_{mm}^{(k)} = e_m^TA^{(k)}e_m = e_m^T({Q'}^{(k)})^TA{Q'}^{(k)}e_m
= (q_m^{(k)})^TAq_{m} = \mu^{(k)}.\]</div>
</div></blockquote>
<p>This is very cheap, we just read off the bottom right-hand corner
from <span class="math notranslate nohighlight">\(A^{(k)}\)</span>! This is called the Rayleigh quotient shift.</p>
<p>It turns out that the Rayleigh quotient shift is not guaranteed to
work in all cases, so there is an alternative approach called the
Wilkinson shift, but we won’t discuss that here.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020-2023, Colin J. Cotter.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    </div>
  </body>
</html>